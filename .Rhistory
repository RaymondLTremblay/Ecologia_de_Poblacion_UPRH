LT5=LT4 %>%
mutate("lxbxx"=bx*lx*Year_after_first_flowering)
LT5
sumlxbxx=LT5 %>% select(lxbxx) %>%
summarise(sum =sum(lxbxx, na.rm = TRUE))
LT5
#########
# Distribución normal
mean = 7.1
stdev = 10.9
curve(dnorm(x,mean,stdev),0,15,ylab="Probability (density)",xlab="Possibilities",main="Normal distribution (continuous)")   # probability density
#########
# Distribución normal
mean = 7.1
stdev = 5.9
curve(dnorm(x,mean,stdev),0,15,ylab="Probability (density)",xlab="Possibilities",main="Normal distribution (continuous)")   # probability density
#########
# Distribución normal
mean = 7.1
stdev = 5.9
curve(dnorm(x,mean,stdev),15,15,ylab="Probability (density)",xlab="Possibilities",main="Normal distribution (continuous)")   # probability density
#########
# Distribución normal
mean = 7.1
stdev = 1.9
curve(dnorm(x,mean,stdev),0,15,ylab="Probability (density)",xlab="Possibilities",main="Normal distribution (continuous)")   # probability density
x=rnorm(0,1)
x=as.tibble(x)
x
x=rnorm(0,1, 1000)
x=as.tibble(x)
x
x=rnorm(1000, 0,1 )
x=as.tibble(x)
x
ggplot(x, aes(value))+
geom_density()
x=rnorm(100000, 0,1 )
x=as.tibble(x)
ggplot(x, aes(value))+
geom_density()
x=rnorm(1000000, 0,1 )
x=as.tibble(x)
ggplot(x, aes(value))+
geom_density()
caras=c(4,7, 6, 8, 5, 4,3,7,7,2)
caras=as_tibble(caras)
caras
ggplot(caras, aes(value))+
geom_histogram(aes(y=..density..))
library(tidyverse)
caras=c(4,7, 6, 8, 5, 4,3,7,7,2,
9, 3, 5,4, 5, 4, 4,2,6,5)
caras=as_tibble(caras)
caras
ggplot(caras, aes(value))+
geom_histogram(aes(y=..density..))
knitr::opts_chunk$set(echo = TRUE)
library('popbio')
library('popdemo')
#library('modeest')
#matrices of transitions for sub-population 1
popState <- c(13, 16, 2, 19) #vector of sub-population 1 abundances for last year of observations
transMat    <- list() #matrix of transitions
transMat$T1 <- rbind(c(0.7869273, 0, 0.8300450, 0), c(0.1760353, 0.97248154, 0, 0), c(0, 0.01578038, 0.5746824, 0.07676408), c(0, 0, 0.4162108, 0.92323588))
transMat$T2 <- rbind(c(0.8285143, 0, 5.542540e-10 , 0), c(0.1396047, 0.96356898, 0, 0), c(0, 0.02150297, 0.4921383, 0.08007071), c(0, 0, 0.4983780, 0.91992925))
transMat$T3 <- rbind(c(0.8503599, 0, 5.636965e-10 , 0), c(0.1052920, 0.96467304, 0, 0), c(0, 0.01998974, 0.4835024, 0.08807574), c(0, 0, 0.5073186, 0.91192422))
transMat$T4 <- rbind(c(0.90264580, 0, 5.235940e-10, 0), c(0.06590077, 0.9630270, 0, 0), c(0, 0.0208872, 0.5139655, 0.08746788), c(0, 0, 0.4768932, 0.91253208))
transMat$T5 <- rbind(c(0.91771803, 0, 0.3499083, 0), c(0.05391462, 0.97005810, 0, 0), c(0, 0.01632058, 0.4419389, 0.07880436), c(0, 0, 0.5489797, 0.92119559))
transMat$T6 <- rbind(c(0.87316400, 0, 1.687415e-10, 0), c(0.08590074, 0.95334666, 0, 0), c(0, 0.02579743, 4.139104e-01, 0.08205262), c(0, 0, 5.766711e-01, 0.91794733))
transMat$T7 <- rbind(c(0.90703646, 0, 6.906485e-10, 0), c(0.06060516, 0.96867738, 0, 0), c(0, 0.01777129, 4.849267e-01, 0.07774181), c(0, 0, 5.058289e-01, 0.92225814))
transMat$T8 <- rbind(c(0.93404923, 0, 3.449700e-10, 0), c(0.04564076, 0.97236335, 0, 0), c(0, 0.01519189, 4.806209e-01, 0.07931822), c(0, 0, 5.101786e-01, 0.92068174))
transMat$T9 <- rbind(c(0.88524275, 0, 1.565175e-10, 0), c(0.07985631, 0.9613211, 0, 0), c(0, 0.0211242, 3.741810e-01, 0.08446428), c(0, 0, 6.166460e-01, 0.91553567))
transMat$T10 <- rbind(c(0.91569045, 0, 3.667075e-10, 0), c(0.05907888, 0.97480231, 0, 0), c(0, 0.01365979, 5.778412e-01, 0.07328772), c(0, 0, 4.130556e-01, 0.92671224))
transMat$T11 <- rbind(c(0.9170242, 0, 3.657935e-10, 0), c(0.0573607, 0.97434500, 0, 0), c(0, 0.01424255, 4.055471e-01, 0.07605183), c(0, 0, 5.854003e-01, 0.92394813))
transMat$T12 <- rbind(c(0.91868350, 0, 8.395985e-10, 0), c(0.05698844, 0.97126869, 0, 0), c(0, 0.01620411, 4.599883e-01, 0.07786934), c(0, 0, 5.308060e-01, 0.92213062))
transMat$T13 <- rbind(c(0.8933651, 0, 0.4218637, 0), c(0.0754819, 0.96883951, 0, 0), c(0, 0.01741538, 0.4741468, 0.08011046), c(0, 0, 0.5166038, 0.91988950))
transMat$T14 <- rbind(c(0.8941097, 0, 4.074855e-10, 0), c(0.0751373, 0.96842970, 0, 0), c(0, 0.01771008, 4.739166e-01, 0.07977865), c(0, 0, 5.167966e-01, 0.92022130))
transMat$T15 <- rbind(c(0.89332212, 0, 4.823470e-10, 0), c(0.07570813, 0.96829439, 0, 0), c(0, 0.01776341, 4.761405e-01, 0.08013242), c(0, 0, 5.145436e-01, 0.91986753))
transMat$T16 <- rbind(c(0.89225132, 0, 5.007945e-10, 0), c(0.07662393, 0.96863160, 0, 0), c(0, 0.01747498, 4.780552e-01, 0.08001434), c(0, 0, 5.126394e-01, 0.91998562))
transMat$T17 <- rbind(c(0.89289170, 0, 0.9053583, 0), c(0.07597438, 0.96813832, 0, 0), c(0, 0.01785388, 0.4746140, 0.08009411), c(0, 0, 0.5160928, 0.91990584))
transMat$T18 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T19 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T20 <- rbind(c(0.89279674, 0, 11.7187000, 0), c(0.07637371, 0.96860413, 0, 0), c(0, 0.01752984, 0.4744193, 0.08030667), c(0, 0, 0.5162513, 0.91969328))
transMat$T21 <- rbind(c(0.89453969, 0, 0.1771410, 0), c(0.07457337, 0.96833046, 0, 0), c(0, 0.01773764, 0.4751942, 0.07996677), c(0, 0, 0.5155116, 0.92003319))
transMat$T22 <- rbind(c(0.89360562, 0, 2.087290e-10, 0), c(0.07532944, 0.96833477, 0, 0), c(0, 0.01768248, 4.714852e-01, 0.08010061), c(0, 0, 5.192556e-01, 0.91989934))
transMat$T23 <- rbind(c(0.8920189, 0, 3.928490e-10, 0), c(0.0768873, 0.96852428, 0, 0), c(0, 0.01750726, 4.745888e-01, 0.07982504), c(0, 0, 5.161487e-01, 0.92017492))
transMat$T24 <- rbind(c(0.89387344, 0, 0.3548790, 0), c(0.07528274, 0.96816469, 0, 0), c(0, 0.01784024, 0.4740048, 0.08062855), c(0, 0, 0.5167163, 0.91937140))
#calculate the average transition matrix
meanT 	= mean(transMat)
print(meanT)
sdT 	= sqrt(var2(transMat))
print(sdT)
lambda 	= lambda(meanT)
cat('lambda', lambda, '\n')
ss 		= stable.stage(meanT)
cat('stable stage', ss, '\n')
rv 		= reproductive.value(meanT)
cat('reproductive value', rv, '\n')
elas 	= elasticity(meanT)
cat('elasticity', '\n')
print(elas)
cat('transfer function analysis',  '\n')
ele.mat <- matrix(NA, 4,4)
ele.mat[1,3] <- "F"
ele.mat[1,1] <- "P"
ele.mat[2,1] <- "P"
ele.mat[2,2] <- "P"
ele.mat[3,2] <- "P"
ele.mat[3,3] <- "P"
ele.mat[4,3] <- "P"
ele.mat[3,4] <- "P"
ele.mat[4,4] <- "P"
par(mfrow=c(4,4))
par(mar=c(4.1, 4.1, 1.1, 1.1))
zeros <- c(0, 0, 0, 0)
for(i in 1:4) {
for(j in 1:4) {
if(meanT[i,j] <= 1e-10) {
plot(0,xaxt='n',yaxt='n',bty='n',pch='',ylab='',xlab='')
next()
}
d1 	  <- e1 <- zeros
d1[i] <- 1
e1[j] <- 1
delta <- 1*seq(-meanT[i,j], meanT[i,j], 0.01)
tf1 <- tfa_lambda(meanT, d = d1, e = e1, prange = delta)
plot(tf1)#, xlab="Perturbation", ylab=expression(lambda))
s76 <- sens(meanT)[i, j]
abline(eigs(meanT, "lambda"), s76, lty = 2)
}
}
popSGR 			= stoch.growth.rate(transMat, verbose=F)
lambdaCI 		= list()
lambdaCI$approx	= exp(popSGR$approx)
lambdaCI$sim 	= exp(popSGR$sim)
lambdaCI$sim.CI	= exp(popSGR$sim.CI)
cat('lambda\n')
print(lambdaCI)
#Runs the projections. nreps is the number of replications. Takes awhile to run
popProject	= stoch.projection(matrices=transMat, n0=popState, tmax=240, nmax=1000, nreps=1e4, prob=rep(1/24, length=24), verbose=FALSE)
totPopSize 	= apply(popProject, 1, sum)
hist(totPopSize, breaks=100, col="black", border="white", xlab="Final population size at t=240 (24 years)", main='Sub-population 1')
graphics.off()
#mlvPop = mlv(totPopSize, method = "naive")
extin=c()
popQuant = matrix(NA, 3, 241)
popQuant[,1] = rep(sum(popState), 3)
popMean	= vector('numeric', 241)
popMean[1] = sum(popState)
popSD	= vector('numeric', 241)
popSD[1] = NA
for(i in 1:240){
matriz=c()
interactionX=1000
quasi=2
popExtinctProject<-stoch.projection(matrices=transMat, n0=popState, tmax=i, nmax=1000, nreps = interactionX, prob = rep(1/24, length=24), verbose=FALSE)
for(ii in 1:interactionX){
a=sum(popExtinctProject[ii,])
matriz<-rbind(matriz,c(a))
}
vv=matriz[matriz<quasi]
s=length(vv)
extin=c(extin,s)
popQuant[,i+1] <- quantile(apply(popExtinctProject, 1, sum), probs=c(0.025, 0.5, 0.975))
popMean[i+1] 	= mean(apply(popExtinctProject, 1, sum))
popSD[i+1] 		= sd(apply(popExtinctProject, 1, sum))
}
plot(popMean, xlab="Time (months)", ylab="Number of individuals (n)", type='l', main="Sub-pop 1", lwd=2, ylim=c(0,max(popQuant, na.rm=T)))
lines(popQuant[1,])
lines(popQuant[3,])
graphics.off()
plot(extin/interactionX, type='l', lwd=2, xlab="Months into future", main="Extinction probability for sub-population 1")
knitr::opts_chunk$set(echo = TRUE)
library('popbio')
library('popdemo')
#library('modeest')
#matrices of transitions for sub-population 1
popState <- c(13, 16, 2, 19) #vector of sub-population 1 abundances for last year of observations
transMat    <- list() #matrix of transitions
transMat$T1 <- rbind(c(0.7869273, 0, 0.8300450, 0), c(0.1760353, 0.97248154, 0, 0), c(0, 0.01578038, 0.5746824, 0.07676408), c(0, 0, 0.4162108, 0.92323588))
transMat$T2 <- rbind(c(0.8285143, 0, 5.542540e-10 , 0), c(0.1396047, 0.96356898, 0, 0), c(0, 0.02150297, 0.4921383, 0.08007071), c(0, 0, 0.4983780, 0.91992925))
transMat$T3 <- rbind(c(0.8503599, 0, 5.636965e-10 , 0), c(0.1052920, 0.96467304, 0, 0), c(0, 0.01998974, 0.4835024, 0.08807574), c(0, 0, 0.5073186, 0.91192422))
transMat$T4 <- rbind(c(0.90264580, 0, 5.235940e-10, 0), c(0.06590077, 0.9630270, 0, 0), c(0, 0.0208872, 0.5139655, 0.08746788), c(0, 0, 0.4768932, 0.91253208))
transMat$T5 <- rbind(c(0.91771803, 0, 0.3499083, 0), c(0.05391462, 0.97005810, 0, 0), c(0, 0.01632058, 0.4419389, 0.07880436), c(0, 0, 0.5489797, 0.92119559))
transMat$T6 <- rbind(c(0.87316400, 0, 1.687415e-10, 0), c(0.08590074, 0.95334666, 0, 0), c(0, 0.02579743, 4.139104e-01, 0.08205262), c(0, 0, 5.766711e-01, 0.91794733))
transMat$T7 <- rbind(c(0.90703646, 0, 6.906485e-10, 0), c(0.06060516, 0.96867738, 0, 0), c(0, 0.01777129, 4.849267e-01, 0.07774181), c(0, 0, 5.058289e-01, 0.92225814))
transMat$T8 <- rbind(c(0.93404923, 0, 3.449700e-10, 0), c(0.04564076, 0.97236335, 0, 0), c(0, 0.01519189, 4.806209e-01, 0.07931822), c(0, 0, 5.101786e-01, 0.92068174))
transMat$T9 <- rbind(c(0.88524275, 0, 1.565175e-10, 0), c(0.07985631, 0.9613211, 0, 0), c(0, 0.0211242, 3.741810e-01, 0.08446428), c(0, 0, 6.166460e-01, 0.91553567))
transMat$T10 <- rbind(c(0.91569045, 0, 3.667075e-10, 0), c(0.05907888, 0.97480231, 0, 0), c(0, 0.01365979, 5.778412e-01, 0.07328772), c(0, 0, 4.130556e-01, 0.92671224))
transMat$T11 <- rbind(c(0.9170242, 0, 3.657935e-10, 0), c(0.0573607, 0.97434500, 0, 0), c(0, 0.01424255, 4.055471e-01, 0.07605183), c(0, 0, 5.854003e-01, 0.92394813))
transMat$T12 <- rbind(c(0.91868350, 0, 8.395985e-10, 0), c(0.05698844, 0.97126869, 0, 0), c(0, 0.01620411, 4.599883e-01, 0.07786934), c(0, 0, 5.308060e-01, 0.92213062))
transMat$T13 <- rbind(c(0.8933651, 0, 0.4218637, 0), c(0.0754819, 0.96883951, 0, 0), c(0, 0.01741538, 0.4741468, 0.08011046), c(0, 0, 0.5166038, 0.91988950))
transMat$T14 <- rbind(c(0.8941097, 0, 4.074855e-10, 0), c(0.0751373, 0.96842970, 0, 0), c(0, 0.01771008, 4.739166e-01, 0.07977865), c(0, 0, 5.167966e-01, 0.92022130))
transMat$T15 <- rbind(c(0.89332212, 0, 4.823470e-10, 0), c(0.07570813, 0.96829439, 0, 0), c(0, 0.01776341, 4.761405e-01, 0.08013242), c(0, 0, 5.145436e-01, 0.91986753))
transMat$T16 <- rbind(c(0.89225132, 0, 5.007945e-10, 0), c(0.07662393, 0.96863160, 0, 0), c(0, 0.01747498, 4.780552e-01, 0.08001434), c(0, 0, 5.126394e-01, 0.91998562))
transMat$T17 <- rbind(c(0.89289170, 0, 0.9053583, 0), c(0.07597438, 0.96813832, 0, 0), c(0, 0.01785388, 0.4746140, 0.08009411), c(0, 0, 0.5160928, 0.91990584))
transMat$T18 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T19 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T20 <- rbind(c(0.89279674, 0, 11.7187000, 0), c(0.07637371, 0.96860413, 0, 0), c(0, 0.01752984, 0.4744193, 0.08030667), c(0, 0, 0.5162513, 0.91969328))
transMat$T21 <- rbind(c(0.89453969, 0, 0.1771410, 0), c(0.07457337, 0.96833046, 0, 0), c(0, 0.01773764, 0.4751942, 0.07996677), c(0, 0, 0.5155116, 0.92003319))
transMat$T22 <- rbind(c(0.89360562, 0, 2.087290e-10, 0), c(0.07532944, 0.96833477, 0, 0), c(0, 0.01768248, 4.714852e-01, 0.08010061), c(0, 0, 5.192556e-01, 0.91989934))
transMat$T23 <- rbind(c(0.8920189, 0, 3.928490e-10, 0), c(0.0768873, 0.96852428, 0, 0), c(0, 0.01750726, 4.745888e-01, 0.07982504), c(0, 0, 5.161487e-01, 0.92017492))
transMat$T24 <- rbind(c(0.89387344, 0, 0.3548790, 0), c(0.07528274, 0.96816469, 0, 0), c(0, 0.01784024, 0.4740048, 0.08062855), c(0, 0, 0.5167163, 0.91937140))
#calculate the average transition matrix
meanT 	= mean(transMat)
print(meanT)
sdT 	= sqrt(var2(transMat))
print(sdT)
lambda 	= lambda(meanT)
cat('lambda', lambda, '\n')
ss 		= stable.stage(meanT)
cat('stable stage', ss, '\n')
rv 		= reproductive.value(meanT)
cat('reproductive value', rv, '\n')
elas 	= elasticity(meanT)
cat('elasticity', '\n')
print(elas)
cat('transfer function analysis',  '\n')
ele.mat <- matrix(NA, 4,4)
ele.mat[1,3] <- "F"
ele.mat[1,1] <- "P"
ele.mat[2,1] <- "P"
ele.mat[2,2] <- "P"
ele.mat[3,2] <- "P"
ele.mat[3,3] <- "P"
ele.mat[4,3] <- "P"
ele.mat[3,4] <- "P"
ele.mat[4,4] <- "P"
par(mfrow=c(4,4))
par(mar=c(4.1, 4.1, 1.1, 1.1))
zeros <- c(0, 0, 0, 0)
for(i in 1:4) {
for(j in 1:4) {
if(meanT[i,j] <= 1e-10) {
plot(0,xaxt='n',yaxt='n',bty='n',pch='',ylab='',xlab='')
next()
}
d1 	  <- e1 <- zeros
d1[i] <- 1
e1[j] <- 1
delta <- 1*seq(-meanT[i,j], meanT[i,j], 0.01)
tf1 <- tfa_lambda(meanT, d = d1, e = e1, prange = delta)
plot(tf1)#, xlab="Perturbation", ylab=expression(lambda))
s76 <- sens(meanT)[i, j]
abline(eigs(meanT, "lambda"), s76, lty = 2)
}
}
popSGR 			= stoch.growth.rate(transMat, verbose=F)
lambdaCI 		= list()
lambdaCI$approx	= exp(popSGR$approx)
lambdaCI$sim 	= exp(popSGR$sim)
lambdaCI$sim.CI	= exp(popSGR$sim.CI)
cat('lambda\n')
print(lambdaCI)
#Runs the projections. nreps is the number of replications. Takes awhile to run
popProject	= stoch.projection(matrices=transMat, n0=popState, tmax=240, nmax=1000, nreps=1e4, prob=rep(1/24, length=24), verbose=FALSE)
totPopSize 	= apply(popProject, 1, sum)
hist(totPopSize, breaks=100, col="black", border="white", xlab="Final population size at t=240 (24 years)", main='Sub-population 1')
graphics.off()
#mlvPop = mlv(totPopSize, method = "naive")
extin=c()
popQuant = matrix(NA, 3, 241)
popQuant[,1] = rep(sum(popState), 3)
popMean	= vector('numeric', 241)
popMean[1] = sum(popState)
popSD	= vector('numeric', 241)
popSD[1] = NA
for(i in 1:240){
matriz=c()
interactionX=1000
quasi=2
popExtinctProject<-stoch.projection(matrices=transMat, n0=popState, tmax=i, nmax=1000, nreps = interactionX, prob = rep(1/24, length=24), verbose=FALSE)
for(ii in 1:interactionX){
a=sum(popExtinctProject[ii,])
matriz<-rbind(matriz,c(a))
}
vv=matriz[matriz<quasi]
s=length(vv)
extin=c(extin,s)
popQuant[,i+1] <- quantile(apply(popExtinctProject, 1, sum), probs=c(0.025, 0.5, 0.975))
popMean[i+1] 	= mean(apply(popExtinctProject, 1, sum))
popSD[i+1] 		= sd(apply(popExtinctProject, 1, sum))
}
plot(popMean, xlab="Time (months)", ylab="Number of individuals (n)", type='l', main="Sub-pop 1", lwd=2, ylim=c(0,max(popQuant, na.rm=T)))
lines(popQuant[1,])
lines(popQuant[3,])
graphics.off()
plot(extin/interactionX, type='l', lwd=2, xlab="Months into future", main="Extinction probability for sub-population 1")
knitr::opts_chunk$set(echo = TRUE)
library(popdemo)
library(popbio)
Tis=matrix(c(
0,0,0,0.007,0.017,0.036,0,.001,0.011,0.024,0.035,
0.28,0.167,0,0,0,0,0,0,0,0,0,
0,.33,.189,0,0,0,0,0,0,0,0,
0,.103,.378,.134,0,0,0,0,0,0,0,
0,0,.081,.179,.066,0,0,0,0,0,0,
0,0,0.014,0,0.082,0,0,0,0,0,0,
0,.039,0.108,.448,.754,.940,0,.300,0.570,.985,1.243,
0,0,0,0,0,0,.033,.57,0,0,0,
0,0,0,0,0,0,.148,.183,.035,0,0,
0,0,0,0,0,0,.18,.207,.193,.037,0,
0,0,0,0,0,0,.115,.126,.175,.066,0
), byrow=TRUE, ncol=11)
Tis
library(Rage)
plot_life_cycle(Tis)
isErgodic(Tis, digits=10, return.eigvec=FALSE)
isIrreducible(Tis)
eigs <- eigen(Tis)
eigs
lambdamax <- Re(eigs$values[1])
lambdamax
lambda(Tis)
truelambda(Tis)
w <- stable.stage(Tis)
w
v <- reproductive.value(Tis)
v
sens(Tis)
elas(Tis)
par(mar=c(10,4,1,1))
n0.amp <- c(1000,1,1,1,1,1,1,1,1,1,1)
n0.att <- c(1,1,1,1,1,1,1,1,1,1,1000)
pr2.1 <- project(Tis, vector=n0.amp, time=156,
standard.A=T, standard.vec=T)
pr2.2 <- project(Tis, vector=n0.att, time=156,
standard.A=T, standard.vec=T)
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
#maxamp(Tis, vector=n0.amp)
reac(Tis,vector=n0.amp)
inertia(Tis,vector=n0.amp)
reac <- reac(Tis, vector=n0.amp)
#maxamp <- maxamp(Tis, vector=n0.amp, return.t=T)
upinertia <- inertia(Tis, vector=n0.amp)
#points(c(1,maxamp$t,31), c(reac,upinertia),
#       pch=3, col="red")
#text(1, reac, expression(bar(P)[1]),
#     adj=c(-0.3,0.5), col="red", cex=0.8)
#text(maxamp$t, maxamp$maxamp, expression(bar(P)[max]),
#    adj=c(0.1,-0.5), col="red", cex=0.8)
#text(31, upinertia, expression(bar(P)[infinity]),
#     adj=c(0.1,-0.5), col="red", cex=0.8)
n0 <- c(48, 16, 12, 10)
tfmat <- tfamatrix(Tis)
#...and plot it!
plot(tfmat)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
df <- data.frame(
Vital_Rate = c("Surv","Surv","Fec","Fec"),
sex = c("F","M","F (daughters)","M (sons)"),
CV = c(0.111,0.185,0.350, 0.291),
min_CV = c(0.102,0.136,0.303,0.268),
max_CV = c(0.119,0.201,0.376,0.331)
)
df
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(MASS)
fitdistr(hatch_perfem,"log-normal")
#############
# Demostración: ¡use datos para determinar una distribución!
#############
#############
# Made-up canvasback data- average number of eggs hatched per female for 20 years
hatch_perfem <- c(3.05, 1.45, 0.99, 3.24, 1.49, 1.70, 1.66, 2.32, 0.83, 2.41,
2.33, 1.68, 1.43, 2.74, 2.05, 3.13, 1.90, 3.69, 1.55, 2.79)
hist(hatch_perfem)
############
# Trate de identificar una distribución logarítmica normal de números aleatorios para representar la 'canvasback duck' data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
## ahora, superponga una distribución de probabilidad logarítmica normal con parámetros arbitrarios (meanlog y sdlog). Esto es sólo un punto de partida.
curve(dlnorm(x,meanlog=1.5,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1.8,sdlog=0.39),col="green",lty=2,lwd=2,add=T)    # try a different value...
#### ¡Siga cambiando el valor de 'meanlog' hasta que encuentre los mejores parámetros que se ajusten a los datos!
#### Una vez que encuentre los parámetros que mejor se ajusten, genere 5 números aleatorios a partir de esta distribución usando la función "rlnorm ()" en R.
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
library(MASS)
fitdistr(hatch_perfem,"log-normal")
############
# Trate de identificar una distribución logarítmica normal de números aleatorios para representar la 'canvasback duck' data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
## ahora, superponga una distribución de probabilidad logarítmica normal con parámetros arbitrarios (meanlog y sdlog). Esto es sólo un punto de partida.
curve(dlnorm(x,meanlog=1.5,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1.8,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1,sdlog=0.39),col="red",lty=2,lwd=2,add=T) # try a different value...
#### ¡Siga cambiando el valor de 'meanlog' hasta que encuentre los mejores parámetros que se ajusten a los datos!
#### Una vez que encuentre los parámetros que mejor se ajusten, genere 5 números aleatorios a partir de esta distribución usando la función "rlnorm ()" en R.
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
############
# Trate de identificar una distribución logarítmica normal de números aleatorios para representar la 'canvasback duck' data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
## ahora, superponga una distribución de probabilidad logarítmica normal con parámetros arbitrarios (meanlog y sdlog). Esto es sólo un punto de partida.
curve(dlnorm(x,meanlog=1.5,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1.8,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=2.0,sdlog=0.39),col="red",lty=2,lwd=2,add=T) # try a different value...
#### ¡Siga cambiando el valor de 'meanlog' hasta que encuentre los mejores parámetros que se ajusten a los datos!
#### Una vez que encuentre los parámetros que mejor se ajusten, genere 5 números aleatorios a partir de esta distribución usando la función "rlnorm ()" en R.
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
library(MASS)
fitdistr(hatch_perfem,"log-normal")
install.packages(c("backports", "bayestestR", "broom", "cli", "conquer", "crayon", "fda", "future", "generics", "labelled", "lattice", "mgcv", "nlme", "ragg", "robust", "sessioninfo", "survival", "systemfonts", "tzdb", "usethis", "uuid"))
fitdistr(hatch_perfem,"lognormal")
hatch_perfem/5
hacth_5_years=hatch_perfem/5
hatch_5_years=hatch_perfem/5
fitdistr(hacth_perfem,"log-normal")
fitdistr(hatch_5_years,"log-normal")
rlnorm(1000, -0.92822498, 0.38756090)
data=rlnorm(1000, -0.92822498, 0.38756090)
e^data
data
log2(data)
log(2)
c=log(2)
exp(c)
exp(data)
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
hatch_5_years=hatch_perfem/5
fitdistr(hatch_5_years,"log-normal")
data=rlnorm(1000, -0.92822498, 0.38756090)
exp(data)  # USe exp to convert he values from lognotmal to numbers again.
#c=log(2)
#exp(c)
rbeta(10, 2.5, 6)
round(rbeta(10, 2.5, 6), 3)
Larva_supevivencia= c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.117, 0.148, 0.171, 0.257)
fitdistr(Larva_supevivencia,"beta")
Larva_supevivencia=c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.117, 0.148, 0.171, 0.257)
fitdistr(Larva_supevivencia,"beta")
install.packages("fitdistrplus")
library(fitdistrplus)
fitdistr(hatch_perfem,"log-normal")
fitdistr(Larva_supevivencia,"beta")
fitdist(Larva_supevivencia,"beta")
plot(fit, las=1)
fit=fitdist(Larva_supevivencia,"beta")
plot(fit, las=1)
Larva_supevivencia=c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.207, 0.148, 0.171, 0.257)
fit=fitdist(Larva_supevivencia,"beta")
plot(fit, las=1)
fit
plot(fit, las=1)
beta_mom <- function(x) {
m_x <- mean(x, na.rm = TRUE)
s_x <- sd(x, na.rm = TRUE)
alpha <- m_x*((m_x*(1 - m_x)/s_x^2) - 1)
beta <- (1 - m_x)*((m_x*(1 - m_x)/s_x^2) - 1)
return(list(alpha = alpha, beta = beta))
}
beta_mom(x)
Larva_supevivencia=c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.207, 0.148, 0.171, 0.257)
beta_mom(Larva_supevivencia)
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.326, 0.207, 0.148, 0.171, 0.257)
beta_mom(Larva_supevivencia)
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.226, 0.207, 0.148, 0.171, 0.257)
beta_mom(Larva_supevivencia)
fit=fitdist(Larva_supevivencia,"beta")
fit
plot(fit, las=1)
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.226, 0.207, 0.178, 0.171, 0.257)
beta_mom(Larva_supevivencia)
fit=fitdist(Larva_supevivencia,"beta")
fit
plot(fit, las=1)
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(100,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Poisson random number generator
rpois(10,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### beta random number generator (bounded between 0 and 1- just like survival rate!)
rbeta(1,shape1=10,shape2=3)  # beta distribution is defined by "shape1" and "shape2", which together define the mean and spread within the range from 0 to 1.
### beta random number generator (bounded between 0 and 1- just like survival rate!)
rbeta(1,shape1=10,shape2=3)  # beta distribution is defined by "shape1" and "shape2", which together define the mean and spread within the range from 0 to 1.
